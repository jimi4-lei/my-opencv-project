#include <opencv2/opencv.hpp>
#include <iostream>
#include <string>

using namespace cv;
using namespace std;

class BackgroundChanger {
private:
    // ç™½è‰²é˜ˆå€¼èŒƒå›´ (BGRæ ¼å¼)
    int whiteThreshold = 200;

public:
    // è®¾ç½®ç™½è‰²é˜ˆå€¼
    void setWhiteThreshold(int threshold) {
        whiteThreshold = threshold;
    }

    // æ–¹æ³•1: åŸºäºé¢œè‰²é˜ˆå€¼æ›¿æ¢èƒŒæ™¯
    Mat changeBackgroundToBlack(const Mat& input) {
        Mat result = input.clone();
        
        // éå†æ¯ä¸ªåƒç´ 
        for (int i = 0; i < result.rows; i++) {
            for (int j = 0; j < result.cols; j++) {
                Vec3b pixel = result.at<Vec3b>(i, j);
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç™½è‰²èƒŒæ™¯ (BGRå€¼éƒ½å¤§äºé˜ˆå€¼)
                if (pixel[0] > whiteThreshold && pixel[1] > whiteThreshold && pixel[2] > whiteThreshold) {
                    // å°†ç™½è‰²åƒç´ æ”¹ä¸ºé»‘è‰²
                    result.at<Vec3b>(i, j) = Vec3b(0, 0, 0);
                }
            }
        }
        
        return result;
    }
};
int main(int argc, char** argv) {
    // æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°
    if (argc < 3) {
        cout << "ä½¿ç”¨æ–¹æ³•: " << argv[0] << " <è¾“å…¥å›¾ç‰‡è·¯å¾„> <è¾“å‡ºå›¾ç‰‡è·¯å¾„> [é˜ˆå€¼]" << endl;
        cout << "ç¤ºä¾‹: " << argv[0] << " input.jpg output.jpg 200" << endl;
        cout << "é˜ˆå€¼èŒƒå›´: 180-230 (é»˜è®¤200)" << endl;
        return -1;
    }

    string inputPath = argv[1];
    string outputPath = argv[2];
    
    int threshold = 200; // é»˜è®¤é˜ˆå€¼
    if (argc >= 4) {
        threshold = stoi(argv[3]);
    }

    // è¯»å–å›¾ç‰‡
    Mat originalImage = imread(inputPath);
    
    if (originalImage.empty()) {
        cout << "é”™è¯¯: æ— æ³•è¯»å–å›¾ç‰‡ " << inputPath << endl;
        return -1;
    }

    cout << "âœ… å›¾ç‰‡è¯»å–æˆåŠŸ: " << inputPath << endl;
    cout << "ğŸ“ å›¾ç‰‡å°ºå¯¸: " << originalImage.cols << " x " << originalImage.rows << endl;
    cout << "âš™ï¸  ä½¿ç”¨ç™½è‰²é˜ˆå€¼: " << threshold << endl;

    BackgroundChanger converter;
    converter.setWhiteThreshold(threshold);

    // é€‰æ‹©è½¬æ¢æ–¹æ³•
    int method;
    cout << "\nè¯·é€‰æ‹©è½¬æ¢æ–¹æ³•:" << endl;
    cout << "1. åŸºç¡€é˜ˆå€¼æ›¿æ¢" << endl;
    cin >> method;

    Mat result;
    string methodName;

    switch (method) {
        case 1:
            result = converter.changeBackgroundToBlack(originalImage);
            methodName = "åŸºç¡€é˜ˆå€¼æ›¿æ¢";
            break;
    }

    cout << "ğŸ”„ " << methodName << "å®Œæˆ" << endl;

    // ä¿å­˜ç»“æœ
    bool isSuccess = imwrite(outputPath, result);
    
    if (isSuccess) {
        cout << "ğŸ’¾ èƒŒæ™¯æ›¿æ¢åçš„å›¾ç‰‡å·²ä¿å­˜: " << outputPath << endl;
        
        // ç»Ÿè®¡æ›¿æ¢çš„åƒç´ æ•°é‡
        Mat whiteMask;
        inRange(originalImage, Scalar(threshold, threshold, threshold), 
                Scalar(255, 255, 255), whiteMask);
        int whitePixels = countNonZero(whiteMask);
        
        cout << "ğŸ“Š ç»Ÿè®¡ä¿¡æ¯:" << endl;
        cout << "   æ›¿æ¢çš„ç™½è‰²åƒç´ : " << whitePixels << " ä¸ª" << endl;
        cout << "   å›¾ç‰‡æ€»åƒç´ : " << originalImage.total() << " ä¸ª" << endl;
        cout << "   æ›¿æ¢æ¯”ä¾‹: " << (whitePixels * 100.0 / originalImage.total()) << "%" << endl;
    } else {
        cout << "âŒ ä¿å­˜å›¾ç‰‡å¤±è´¥: " << outputPath << endl;
        return -1;
    }

    return 0;
}

