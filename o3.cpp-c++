#include <opencv2/opencv.hpp>
#include <iostream>
#include <string>
#include <vector>

using namespace cv;
using namespace std;

class RGBChannelSeparator {
public:
    // åˆ†ç¦»å•ä¸ªRGBé€šé“
    Mat extractSingleChannel(const Mat& input, int channelIndex, const string& channelName) {
        // æ£€æŸ¥é€šé“ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
        if (channelIndex < 0 || channelIndex > 2) {
            cerr << "é”™è¯¯: é€šé“ç´¢å¼•å¿…é¡»åœ¨0-2ä¹‹é—´ (0=Blue, 1=Green, 2=Red)" << endl;
            return Mat();
        }
        
        // åˆ†ç¦»é€šé“
        vector<Mat> channels;
        split(input, channels);
        
        // åˆ›å»ºå•é€šé“å›¾åƒï¼ˆé»‘è‰²èƒŒæ™¯ï¼‰
        Mat singleChannel = Mat::zeros(input.size(), CV_8UC3);
        
        // å°†æŒ‡å®šé€šé“å¤åˆ¶åˆ°å¯¹åº”çš„é¢œè‰²å¹³é¢
        vector<Mat> outputChannels(3, Mat::zeros(input.size(), CV_8UC1));
        outputChannels[channelIndex] = channels[channelIndex];
        
        // åˆå¹¶é€šé“
        merge(outputChannels, singleChannel);
        
        cout << "âœ… " << channelName << "é€šé“æå–å®Œæˆ" << endl;
        return singleChannel;
    }
    
    // æå–æ‰€æœ‰RGBé€šé“
    void extractAllChannels(const Mat& input, const string& baseOutputPath) {
        vector<Mat> channels;
        split(input, channels);
        
        // é€šé“åç§°
        vector<string> channelNames = {"Blue", "Green", "Red"};
        vector<Scalar> colors = {Scalar(255, 0, 0), Scalar(0, 255, 0), Scalar(0, 0, 255)};
        
        for (int i = 0; i < 3; i++) {
            // åˆ›å»ºå•é€šé“æ˜¾ç¤ºå›¾åƒ
            Mat singleChannel = Mat::zeros(input.size(), CV_8UC3);
            vector<Mat> outputChannels(3, Mat::zeros(input.size(), CV_8UC1));
            outputChannels[i] = channels[i];
            merge(outputChannels, singleChannel);
            
            // ä¿å­˜å•é€šé“å›¾åƒ
            string outputPath = baseOutputPath + "_" + channelNames[i] + ".jpg";
            imwrite(outputPath, singleChannel);
            
            cout << "ğŸ’¾ " << channelNames[i] << "é€šé“å·²ä¿å­˜: " << outputPath << endl;
            
            // åŒæ—¶ä¿å­˜ç°åº¦ç‰ˆæœ¬
            string grayPath = baseOutputPath + "_" + channelNames[i] + "_gray.jpg";
            imwrite(grayPath, channels[i]);
            cout << "ğŸ’¾ " << channelNames[i] << "é€šé“ç°åº¦å›¾å·²ä¿å­˜: " << grayPath << endl;
        }
    }
    
    // åˆ›å»ºé€šé“å¯¹æ¯”å›¾
    Mat createChannelComparison(const Mat& input) {
        vector<Mat> channels;
        split(input, channels);
        
        // åˆ›å»ºå¯¹æ¯”å›¾åƒ
        Mat comparison;
        hconcat(channels[2], channels[1], comparison); // Red + Green
        Mat temp;
        hconcat(comparison, channels[0], temp); // + Blue
        
        // æ·»åŠ åŸå§‹å›¾åƒ
        hconcat(temp, input, comparison);
        
        return comparison;
    }
};

int main(int argc, char** argv) {
    // æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°
    if (argc < 3) {
        cout << "ä½¿ç”¨æ–¹æ³•: " << argv[0] << " <è¾“å…¥å›¾ç‰‡è·¯å¾„> <è¾“å‡ºè·¯å¾„å‰ç¼€> [é€šé“]" << endl;
        cout << "ç¤ºä¾‹: " << argv[0] << " input.jpg output" << endl;
        cout << "ç¤ºä¾‹: " << argv[0] << " input.jpg output 0 (åªæå–è“è‰²é€šé“)" << endl;
        cout << "é€šé“: 0=Blue, 1=Green, 2=Red, ä¸æŒ‡å®šåˆ™æå–æ‰€æœ‰é€šé“" << endl;
        return -1;
    }

    string inputPath = argv[1];
    string outputPrefix = argv[2];
    
    int specificChannel = -1; // -1è¡¨ç¤ºæå–æ‰€æœ‰é€šé“
    if (argc >= 4) {
        specificChannel = stoi(argv[3]);
    }

    // è¯»å–å›¾ç‰‡
    Mat originalImage = imread(inputPath);
    
    if (originalImage.empty()) {
        cout << "é”™è¯¯: æ— æ³•è¯»å–å›¾ç‰‡ " << inputPath << endl;
        return -1;
    }

    cout << "âœ… å›¾ç‰‡è¯»å–æˆåŠŸ: " << inputPath << endl;
    cout << "ğŸ“ å›¾ç‰‡å°ºå¯¸: " << originalImage.cols << " x " << originalImage.rows << endl;
    cout << "ğŸ¨ é¢œè‰²é€šé“: " << originalImage.channels() << endl;

    RGBChannelSeparator separator;
    
    if (specificChannel >= 0 && specificChannel <= 2) {
        // æå–æŒ‡å®šé€šé“
        vector<string> channelNames = {"Blue", "Green", "Red"};
        Mat singleChannel = separator.extractSingleChannel(originalImage, specificChannel, channelNames[specificChannel]);
        
        if (!singleChannel.empty()) {
            string outputPath = outputPrefix + "_" + channelNames[specificChannel] + "_only.jpg";
            imwrite(outputPath, singleChannel);
            cout << "ğŸ’¾ å•é€šé“å›¾åƒå·²ä¿å­˜: " << outputPath << endl;
        }
    } else {
        // æå–æ‰€æœ‰é€šé“
        cout << "\nğŸ”„ å¼€å§‹æå–æ‰€æœ‰RGBé€šé“..." << endl;
        separator.extractAllChannels(originalImage, outputPrefix);
        
        // åˆ›å»ºé€šé“å¯¹æ¯”å›¾
        Mat comparison = separator.createChannelComparison(originalImage);
        string comparisonPath = outputPrefix + "_channel_comparison.jpg";
        imwrite(comparisonPath, comparison);
        cout << "ğŸ’¾ é€šé“å¯¹æ¯”å›¾å·²ä¿å­˜:"<<comparisonPath<<endl;
    }
    return 0;
}
