import cv2
import numpy as np
import os

def rotate_image_45_left(input_path, output_path=None):
    """
    å°†å›¾ç‰‡å‘å·¦æ—‹è½¬45åº¦
    """
    # è¯»å–å›¾ç‰‡
    img = cv2.imread(input_path)
    if img is None:
        print(f"âŒ é”™è¯¯ï¼šæ— æ³•è¯»å–å›¾ç‰‡ {input_path}")
        return None
    
    print(f"âœ… åŸå§‹å›¾ç‰‡å°ºå¯¸: {img.shape[1]}x{img.shape[0]}")
    
    # è·å–å›¾ç‰‡å°ºå¯¸
    height, width = img.shape[:2]
    
    # è®¡ç®—æ—‹è½¬ä¸­å¿ƒ
    center = (width // 2, height // 2)
    
    # åˆ›å»ºæ—‹è½¬çŸ©é˜µï¼ˆå‘å·¦æ—‹è½¬45åº¦ = é€†æ—¶é’ˆ45åº¦ï¼‰
    rotation_matrix = cv2.getRotationMatrix2D(center, 45, 1.0)
    
    # è®¡ç®—æ—‹è½¬åçš„å›¾ç‰‡å°ºå¯¸
    cos_val = np.abs(rotation_matrix[0, 0])
    sin_val = np.abs(rotation_matrix[0, 1])
    
    new_width = int((height * sin_val) + (width * cos_val))
    new_height = int((height * cos_val) + (width * sin_val))
    
    # è°ƒæ•´æ—‹è½¬çŸ©é˜µçš„å¹³ç§»éƒ¨åˆ†
    rotation_matrix[0, 2] += (new_width / 2) - center[0]
    rotation_matrix[1, 2] += (new_height / 2) - center[1]
    
    # åº”ç”¨æ—‹è½¬
    rotated_img = cv2.warpAffine(img, rotation_matrix, (new_width, new_height), 
                                flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT, 
                                borderValue=(255, 255, 255))  # ç™½è‰²èƒŒæ™¯
    
    print(f"ğŸ“ æ—‹è½¬åå›¾ç‰‡å°ºå¯¸: {new_width}x{new_height}")
    
    # ä¿å­˜ç»“æœ
    if output_path is None:
        name, ext = os.path.splitext(input_path)
        output_path = f"{name}_rotated_45_left{ext}"
    
    cv2.imwrite(output_path, rotated_img)
    print(f"ğŸ’¾ æ—‹è½¬åçš„å›¾ç‰‡å·²ä¿å­˜: {output_path}")
    
    return rotated_img

# ä½¿ç”¨æ–¹æ³•
if __name__ == "__main__":
    input_image =  "/home/huxinlei/å›¾ç‰‡/opencv.jpg" # æ›¿æ¢ä¸ºæ‚¨çš„å›¾ç‰‡è·¯å¾„
    rotated_image = rotate_image_45_left(input_image)
